//===-- PrologueEpilogueInsertionPass.cpp -----------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "CreatePasses.h"
#include "GeneratorContextPass.h"
#include "InitializePasses.h"

#include "snippy/Generator/LLVMState.h"
#include "snippy/Target/Target.h"

#include "llvm/CodeGen/MachineFunctionPass.h"

#define DEBUG_TYPE "snippy-prologue-epilogue-insertion"
#define PASS_DESC "Snippy Prologue Epilogue Insertion"

namespace llvm {
namespace snippy {
namespace {

struct PrologueEpilogueInsertion final : public MachineFunctionPass {
public:
  static char ID;

  PrologueEpilogueInsertion();

  StringRef getPassName() const override { return PASS_DESC " Pass"; }

  bool runOnMachineFunction(MachineFunction &MF) override;

  auto getAllMutatedRegs(MachineFunction &MF) {
    DenseSet<unsigned> MutatedRegs;
    for (auto &MBB : MF)
      for (auto &MI : MBB) {
        for (auto &Def : MI.defs()) {
          assert(Def.isReg() && "Expected register operand");
          MutatedRegs.insert(Def.getReg());
        }
        for (auto &Imp : MI.implicit_operands())
          if (Imp.isDef()) {
            assert(Imp.isReg() && "Expected register operand");
            MutatedRegs.insert(Imp.getReg());
          }
      }
    return MutatedRegs;
  }

  auto getSpilledRegs(MachineFunction &MF) {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    bool IsEntry = SGCtx.isEntryFunction(MF);

    std::vector<unsigned> Ret;

    if (IsEntry)
      std::copy(SGCtx.getSpilledRegs().begin(), SGCtx.getSpilledRegs().end(),
                std::back_inserter(Ret));
    else {
      auto RegSet = getAllMutatedRegs(MF);
      std::copy(RegSet.begin(), RegSet.end(), std::back_inserter(Ret));
    }

    return Ret;
  }

  void generateStackInitialization(MachineBasicBlock &MBB,
                                   MachineBasicBlock::iterator Ins,
                                   RegPoolWrapper &RP);
  void generateStackTermination(MachineBasicBlock &MBB,
                                MachineBasicBlock::iterator Ins,
                                RegPoolWrapper &RP);

  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForPrologue(MachineFunction &MF);
  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForEpilogue(MachineFunction &MF);

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.setPreservesCFG();
    AU.addRequired<GeneratorContextWrapper>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }
};

char PrologueEpilogueInsertion::ID = 0;

} // namespace
} // namespace snippy
} // namespace llvm

using llvm::callDefaultCtor;
using llvm::PassInfo;
using llvm::PassRegistry;
using llvm::snippy::PrologueEpilogueInsertion;

INITIALIZE_PASS(PrologueEpilogueInsertion, DEBUG_TYPE, PASS_DESC, false, false)

namespace llvm {

MachineFunctionPass *createPrologueEpilogueInsertionPass() {
  return new PrologueEpilogueInsertion();
}

namespace snippy {

PrologueEpilogueInsertion::PrologueEpilogueInsertion()
    : MachineFunctionPass(ID) {
  initializePrologueEpilogueInsertionPass(*PassRegistry::getPassRegistry());
}

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForPrologue(MachineFunction &MF) {
  return std::make_pair(&MF.front(), MF.front().begin());
}

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForEpilogue(MachineFunction &MF) {
  auto &MBB = MF.back();

  // FIXME: we need to insert epilogue right before last instruction
  // generated by snippy. For now we know that it is single instruction
  // in the end of last basic block and that it is not required to be
  // terminator.
  auto InsertPos = MBB.empty() ? MBB.end() : std::prev(MBB.end());
  return std::make_pair(&MBB, InsertPos);
}

void PrologueEpilogueInsertion::generateStackInitialization(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator Ins,
    RegPoolWrapper &RP) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  auto StackPointer = SnippyTgt.getStackPointer();
  // Stack ponter is considered live on entry.
  MBB.addLiveIn(StackPointer);

  // Initialize stack.
  // This requires two steps:
  // 1 - save current stack pointer state to top of stack.
  // 2 - set stack pointer to point to next stack slot.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(StackPointer, SGCtx);
  auto Addr = SGCtx.getStackTop() - SPSpillSize;
  assert(Addr % SPSpillSize == 0u && "Stack section must be properly aligned");
  SnippyTgt.storeRegToAddr(MBB, Ins, Addr, StackPointer, RP, SGCtx,
                           /* store the whole register */ 0);
  auto SPInitValue = Addr;
  SnippyTgt.writeValueToReg(
      MBB, Ins,
      APInt(SnippyTgt.getAddrRegLen(State.getTargetMachine()), SPInitValue),
      StackPointer, RP, SGCtx);
}

void PrologueEpilogueInsertion::generateStackTermination(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator Ins,
    RegPoolWrapper &RP) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  // Restore stack pointer state.
  auto StackPointer = SnippyTgt.getStackPointer();
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(StackPointer, SGCtx);
  auto Addr = SGCtx.getStackTop() - SPSpillSize;
  SnippyTgt.loadRegFromAddr(MBB, Ins, Addr, StackPointer, RP, SGCtx);
}

bool PrologueEpilogueInsertion::runOnMachineFunction(MachineFunction &MF) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  if (!SGCtx.stackEnabled())
    return false;

  bool IsEntry = SGCtx.isEntryFunction(MF);

  // 1. Insert Prologue.
  auto &&[MBB, Ins] = findPlaceForPrologue(MF);

  auto SpilledRegs = getSpilledRegs(MF);

  // Forbid spilled registers to be potentially be used as scratch registers
  // for address forming.
  auto RP = SGCtx.getRegisterPool();
  for (auto SpillReg : SpilledRegs)
    RP.addReserved(SpillReg);

  if (IsEntry && !SGCtx.hasExternalStack())
    generateStackInitialization(*MBB, Ins, RP);

  // Spill requested registers. Also mark them as live-in.
  for (auto SpillReg : SpilledRegs) {
    MBB->addLiveIn(SpillReg);
    SnippyTgt.generateSpill(*MBB, Ins, SpillReg, SGCtx);
  }
  if (IsEntry)
    SGCtx.setEntryPrologueInstructionCount(std::distance(MBB->begin(), Ins));

  // 2. Insert epilogue

  std::tie(MBB, Ins) = findPlaceForEpilogue(MF);
  bool BBWasEmptyBeforeEpilogueInsertion = MBB->empty();
  auto Prev = BBWasEmptyBeforeEpilogueInsertion ? MBB->end() : std::prev(Ins);

  // Reload spilled registers.
  std::for_each(SpilledRegs.rbegin(), SpilledRegs.rend(),
                [&, MBB = MBB, Ins = Ins](auto Reg) {
                  SnippyTgt.generateReload(*MBB, Ins, Reg, SGCtx);
                });

  if (IsEntry && !SGCtx.hasExternalStack())
    generateStackTermination(*MBB, Ins, RP);

  auto FirstInserted =
      BBWasEmptyBeforeEpilogueInsertion ? MBB->begin() : std::next(Prev);
  if (IsEntry)
    SGCtx.setEntryEpilogueInstuctionCount(
        std::distance(FirstInserted, MBB->end()));

  return true;
}

} // namespace snippy
} // namespace llvm
